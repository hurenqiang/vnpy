write by hurenqiang

created 2016.03.17

< 模型 > 模式开仓：
    author：符合一定模式之后进行开仓, 计算综合指标
    分类器与训练识别: 优质的样本，即蕴含真实可识别特征的样本

< 模型 > boll布林带变体模型
    author: hurenqiang
    想法：只做横盘整理或震荡后，波动变大走出一段单边的走势
         波动变大的意义：1是短时间内价格迅速变动，2是波动变大走出单边走势
         形象的说，就是布林带变窄持续一段时间比如20个周期或者bar，然后价格波动突破上轨或者下轨
         最大的问题是如何识别出何为噪声何为真实的信号？？？
         中线 = average(P, N)
         上轨 = 中线 + k1*标准差
         下轨 = 中线 - k2*标准差
         止损：一段时间内并未按照预期的方式出现波动，则止损 + 固定额度止损
         止盈：盈利后如果出现反方向波动到一定幅度，则止损

         可以叠加大趋势过滤器，只做方向相同的头寸


< 模型 > 变长range bar的模型
from: vn.py群 印钞机
    变长bar的PCNN思路
    基于tick级别粒度生成变长K线range bar，思路如下：
    1 - 大趋势：识别市场状态（单边/震荡）
    2 - 变长range bar: 
        变长bar固定O-C价格差（非H-L价格差），带单影线的K线，O或者C等于H或L，且影线不产生新一根bar（双方向还可以不一致，具体需要研究变长bar生成策略）
        单边 短，震荡 长：这样单边情况下生成的bar数量更多，震荡下少，bar越多则交易机会越多
        转折数量越少说明趋势越明显，这样的品种越应该考虑
        为了一致性，整点时间时产生自然截断，生成新的bar

        以上两者互相影响：趋势影响bar长度，bar长度影响bar的数量进而影响趋势的识别策略
    3 - 交易算法

    00- PCNN识别趋势状态，识别bar长度
        买卖信号
        日内交易策略

< 模型 > 偏高频套利策略
from 优矿
    基于日内高低点数据统计的交易策略
    -   N（300）日内高低点出现在各个时间段的分布(如: 高点 第一小时 40%  第二小时 10%  第三小时 15% 第四小时 35%)  也可以为统计区间平均价的高低（如TWAP，VWAP）等
                                   (如: 低点 第一小时 35%  第二小时 15%  第三小时 14% 第四小时 36%)
    -   先建仓，然后每天做T策略如下：
        既然第一个小时有40%的概率为高点，那么可以卖出40%的股票，同时买入35%的股票，综合为卖出5%
        余下时间类似
    -   寄希望于整个过程能够产生符合高低点策略的财务回报
        可以统计市场时间段平均价代替最高最低价
    -   风险： 1 这个概率是否是一个稳定的现象，是否可以选股以选择更合适的操作品种
              2 是否有足够高的收益覆盖成本
              3 建仓多少才能够有足够的收益

< 小知识 >  数据处理基本方法 
from 优矿
    去极值化 winsorize：根据样本计算平均值和标准差, 平均值±3标准差意外的数据取边界值，如：市值等可以考虑，消除极值因子的影响
    中性化  neutralize：对于不同行业的股票，其PE基准值可能不一样，无法直接比较，中性化处理后可以进行比较
    标准化  standardize：(因子值 - 因子均值)/因子标准差, 这样不同因子之间才可进行比较分析或者加权计算

< 小知识 >  量化投资基本流派

< 思考 > 海龟交易法则

< 小知识 > 凯利公式
    资金大了之后的有效管理方式
    f = (pb - q)/b  p: 胜率  q: 败率  b: 净赢率(loss为1情况下的简要计算值)
    f = p - q/(w/l) w: win净盈率  l: loss净损率  或者 简单计算为 f = p -q/r   其中 r = w/l 即赔率
    f: 仓位比例

< 熔断超跌错杀股的一种判断方式 >
    第一次熔断为红盘，第二次熔断时杀跌
    首次熔断前小跌，第二次熔断杀跌
    首次熔断后杀跌，但有明显拉升，且第二次熔断后价格竟然高与第一次熔断价格

< 技术指标 >
    MA: sum(price[0:N])/N
    ATR: 真实波动幅度
        TR  = max(high - low, high - lastClose, lastClose - low)
        stdTR = tr / close
        ATR = average(TR[0:N])
        stdATR= average(stdTR[0:N])
    AMA:
    MACD:
    KDJ:
    RSI:
    zigzag:
    itrend:
        price = (high + low)/2.0;
        if (bars.len() < 7){
            // 初始Trend的计算
            if (bars.len() >= 3){
                trend = (price + 2*price[1] + price[2])/4;
            }
        }else{
            trend = (alpha - alpha*alpha/4)*price + 0.5*alpha*alpha*price[1] -
                    (alpha-0.75*alpha*alpha)*price[2]
                    + 2*(1-alpha)*trend[1] - 
                    (1-alpha)*(1-alpha)*trend[2]
        }